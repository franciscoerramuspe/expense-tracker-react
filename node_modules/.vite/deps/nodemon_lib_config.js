import {
  __commonJS,
  __require
} from "./chunk-7FP5O474.js";

// ../../../node_modules/nodemon/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../../node_modules/nodemon/node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../../node_modules/nodemon/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../../node_modules/nodemon/node_modules/debug/src/common.js"(exports, module) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      Object.keys(env).forEach(function(key) {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        var hash = 0;
        for (var i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        var prevTime;
        function debug() {
          if (!debug.enabled) {
            return;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var self = debug;
          var curr = Number(new Date());
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
            if (match === "%%") {
              return match;
            }
            index++;
            var formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              var val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          var logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        createDebug.instances.push(debug);
        return debug;
      }
      function destroy() {
        var index = createDebug.instances.indexOf(this);
        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }
        return false;
      }
      function extend(namespace, delimiter) {
        return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i = 0; i < createDebug.instances.length; i++) {
          var instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      function disable() {
        createDebug.enable("");
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        var i;
        var len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../../../node_modules/nodemon/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../../node_modules/nodemon/node_modules/debug/src/browser.js"(exports, module) {
    "use strict";
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      var _console;
      return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var formatters = module.exports.formatters;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/semver/semver.js
var require_semver = __commonJS({
  "../../../node_modules/semver/semver.js"(exports, module) {
    exports = module.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compare(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.rcompare(a, b, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// ../../../node_modules/nodemon/lib/utils/clone.js
var require_clone = __commonJS({
  "../../../node_modules/nodemon/lib/utils/clone.js"(exports, module) {
    module.exports = clone;
    function clone(obj) {
      if (null === obj || "object" !== typeof obj) {
        return obj;
      }
      var copy;
      if (obj instanceof Date) {
        copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
      }
      if (obj instanceof Array) {
        copy = [];
        for (var i = 0, len = obj.length; i < len; i++) {
          copy[i] = clone(obj[i]);
        }
        return copy;
      }
      if (obj instanceof Object) {
        copy = {};
        for (var attr in obj) {
          if (obj.hasOwnProperty && obj.hasOwnProperty(attr)) {
            copy[attr] = clone(obj[attr]);
          }
        }
        return copy;
      }
      throw new Error("Unable to copy obj! Its type isn't supported.");
    }
  }
});

// ../../../node_modules/nodemon/lib/utils/merge.js
var require_merge = __commonJS({
  "../../../node_modules/nodemon/lib/utils/merge.js"(exports, module) {
    var clone = require_clone();
    module.exports = merge;
    function typesMatch(a, b) {
      return typeof a === typeof b && Array.isArray(a) === Array.isArray(b);
    }
    function merge(source, target, result) {
      if (result === void 0) {
        result = clone(source);
      }
      Object.getOwnPropertyNames(target).forEach(function(key) {
        if (source[key] === void 0) {
          result[key] = target[key];
        }
      });
      Object.getOwnPropertyNames(source).forEach(function(key) {
        var value = source[key];
        if (target[key] && typesMatch(value, target[key])) {
          if (value === "") {
            result[key] = target[key];
          }
          if (Array.isArray(value)) {
            if (value.length === 0 && target[key].length) {
              result[key] = target[key].slice(0);
            }
          } else if (typeof value === "object") {
            result[key] = merge(value, target[key]);
          }
        }
      });
      return result;
    }
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/nodemon/lib/utils/bus.js
var require_bus = __commonJS({
  "../../../node_modules/nodemon/lib/utils/bus.js"(exports, module) {
    var events = require_events();
    var debug = require_browser()("nodemon");
    var util = require_util();
    var Bus = function() {
      events.EventEmitter.call(this);
    };
    util.inherits(Bus, events.EventEmitter);
    var bus = new Bus();
    var collected = {};
    bus.on("newListener", function(event) {
      debug("bus new listener: %s (%s)", event, bus.listeners(event).length);
      if (!collected[event]) {
        collected[event] = true;
        bus.on(event, function() {
          debug("bus emit: %s", event);
        });
      }
    });
    process.on("message", function(event) {
      debug("process.message(%s)", event);
      bus.emit(event);
    });
    var emit = bus.emit;
    if (process.send) {
      bus.emit = function(event, data) {
        process.send({ type: event, data });
        emit.apply(bus, arguments);
      };
    }
    module.exports = bus;
  }
});

// ../../../node_modules/nodemon/lib/utils/colour.js
var require_colour = __commonJS({
  "../../../node_modules/nodemon/lib/utils/colour.js"(exports, module) {
    function colour(c, str) {
      return (colour[c] || colour.black) + str + colour.black;
    }
    function strip(str) {
      re.lastIndex = 0;
      return str.replace(re, "");
    }
    colour.red = "\x1B[31m";
    colour.yellow = "\x1B[33m";
    colour.green = "\x1B[32m";
    colour.black = "\x1B[39m";
    var reStr = Object.keys(colour).map((key) => colour[key]).join("|");
    var re = new RegExp(("(" + reStr + ")").replace(/\[/g, "\\["), "g");
    colour.strip = strip;
    module.exports = colour;
  }
});

// ../../../node_modules/nodemon/lib/utils/log.js
var require_log = __commonJS({
  "../../../node_modules/nodemon/lib/utils/log.js"(exports, module) {
    var colour = require_colour();
    var bus = require_bus();
    var required = false;
    var useColours = true;
    var coding = {
      log: "black",
      info: "yellow",
      status: "green",
      detail: "yellow",
      fail: "red",
      error: "red"
    };
    function log(type, text) {
      var msg = "[nodemon] " + (text || "");
      if (useColours) {
        msg = colour(coding[type], msg);
      }
      process.nextTick(() => {
        bus.emit("log", { type, message: text, colour: msg });
      });
      if (!required) {
        if (type === "error") {
          console.error(msg);
        } else {
          console.log(msg || "");
        }
      }
    }
    var Logger = function(r) {
      if (!(this instanceof Logger)) {
        return new Logger(r);
      }
      this.required(r);
      return this;
    };
    Object.keys(coding).forEach(function(type) {
      Logger.prototype[type] = log.bind(null, type);
    });
    Logger.prototype.detail = function(msg) {
      if (this.debug) {
        log("detail", msg);
      }
    };
    Logger.prototype.required = function(val) {
      required = val;
    };
    Logger.prototype.debug = false;
    Logger.prototype._log = function(type, msg) {
      if (required) {
        bus.emit("log", { type, message: msg || "", colour: msg || "" });
      } else if (type === "error") {
        console.error(msg);
      } else {
        console.log(msg || "");
      }
    };
    Object.defineProperty(Logger.prototype, "useColours", {
      set: function(val) {
        useColours = val;
      },
      get: function() {
        return useColours;
      }
    });
    module.exports = Logger;
  }
});

// ../../../node_modules/nodemon/lib/utils/index.js
var require_utils = __commonJS({
  "../../../node_modules/nodemon/lib/utils/index.js"(exports, module) {
    var noop = function() {
    };
    var path = require_path();
    var semver = require_semver();
    var version = process.versions.node.split(".") || [null, null, null];
    var utils = module.exports = {
      semver,
      satisfies: (test) => semver.satisfies(process.versions.node, test),
      version: {
        major: parseInt(version[0] || 0, 10),
        minor: parseInt(version[1] || 0, 10),
        patch: parseInt(version[2] || 0, 10)
      },
      clone: require_clone(),
      merge: require_merge(),
      bus: require_bus(),
      isWindows: process.platform === "win32",
      isMac: process.platform === "darwin",
      isLinux: process.platform === "linux",
      isRequired: function() {
        var p = module.parent;
        while (p) {
          if (!p.filename) {
            return true;
          }
          if (p.filename.indexOf("bin" + path.sep + "nodemon.js") !== -1) {
            return false;
          }
          p = p.parent;
        }
        return true;
      }(),
      home: process.env.HOME || process.env.HOMEPATH,
      quiet: function() {
        if (!this.debug) {
          for (var method in utils.log) {
            if (typeof utils.log[method] === "function") {
              utils.log[method] = noop;
            }
          }
        }
      },
      reset: function() {
        if (!this.debug) {
          for (var method in utils.log) {
            if (typeof utils.log[method] === "function") {
              delete utils.log[method];
            }
          }
        }
        this.debug = false;
      },
      regexpToText: function(t) {
        return t.replace(/\.\*\\./g, "*.").replace(/\\{2}/g, "^^").replace(/\\/g, "").replace(/\^\^/g, "\\");
      },
      stringify: function(exec, args) {
        args = args || [];
        return [exec].concat(
          args.map(function(arg) {
            if (arg.length > 0 && arg.indexOf(" ") === -1) {
              return arg;
            }
            return JSON.stringify(arg);
          })
        ).join(" ").trim();
      }
    };
    utils.log = require_log()(utils.isRequired);
    Object.defineProperty(utils, "debug", {
      set: function(value) {
        this.log.debug = value;
      },
      get: function() {
        return this.log.debug;
      }
    });
    Object.defineProperty(utils, "colours", {
      set: function(value) {
        this.log.useColours = value;
      },
      get: function() {
        return this.log.useColours;
      }
    });
  }
});

// ../../../node_modules/nodemon/lib/rules/add.js
var require_add = __commonJS({
  "../../../node_modules/nodemon/lib/rules/add.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var reEscComments = /\\#/g;
    var reUnescapeComments = /\^\^/g;
    var reComments = /#.*$/;
    var reEscapeChars = /[.|\-[\]()\\]/g;
    var reAsterisk = /\*/g;
    module.exports = add;
    function add(rules, which, rule) {
      if (!{ ignore: 1, watch: 1 }[which]) {
        throw new Error('rules/index.js#add requires "ignore" or "watch" as the first argument');
      }
      if (Array.isArray(rule)) {
        rule.forEach(function(rule2) {
          add(rules, which, rule2);
        });
        return;
      }
      if (rule instanceof RegExp) {
        utils.log.error("RegExp format no longer supported, but globs are.");
        return;
      }
      rule = (rule || "").replace(reEscComments, "^^").replace(reComments, "").replace(reUnescapeComments, "#").trim();
      var regexp = false;
      if (typeof rule === "string" && rule.substring(0, 1) === ":") {
        rule = rule.substring(1);
        utils.log.error("RegExp no longer supported: " + rule);
        regexp = true;
      } else if (rule.length === 0) {
        return;
      }
      if (regexp) {
      } else {
        rules[which].push(rule);
        var re = rules[which].map(function(rule2) {
          return rule2.replace(reEscapeChars, "\\$&").replace(reAsterisk, ".*");
        }).join("|");
        rules[which].re = new RegExp(re);
      }
    }
  }
});

// ../../../node_modules/nodemon/lib/rules/parse.js
var require_parse = __commonJS({
  "../../../node_modules/nodemon/lib/rules/parse.js"(exports, module) {
    "use strict";
    var fs = require_fs();
    function parse(filename, callback) {
      var rules = {
        ignore: [],
        watch: []
      };
      fs.readFile(filename, "utf8", function(err, content) {
        if (err) {
          return callback(err);
        }
        var json = null;
        try {
          json = JSON.parse(content);
        } catch (e) {
        }
        if (json !== null) {
          rules = {
            ignore: json.ignore || [],
            watch: json.watch || []
          };
          return callback(null, rules);
        }
        return callback(null, { raw: content.split(/\n/) });
      });
    }
    module.exports = parse;
  }
});

// ../../../node_modules/nodemon/lib/rules/index.js
var require_rules = __commonJS({
  "../../../node_modules/nodemon/lib/rules/index.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var add = require_add();
    var parse = require_parse();
    var rules = { ignore: [], watch: [] };
    function load(filename, callback) {
      parse(filename, function(err, result) {
        if (err) {
          utils.log.error(err);
          callback(err);
        }
        if (result.raw) {
          result.raw.forEach(add.bind(null, rules, "ignore"));
        } else {
          result.ignore.forEach(add.bind(null, rules, "ignore"));
          result.watch.forEach(add.bind(null, rules, "watch"));
        }
        callback(null, rules);
      });
    }
    module.exports = {
      reset: function() {
        rules.ignore.length = rules.watch.length = 0;
        delete rules.ignore.re;
        delete rules.watch.re;
      },
      load,
      ignore: {
        test: add.bind(null, rules, "ignore"),
        add: add.bind(null, rules, "ignore")
      },
      watch: {
        test: add.bind(null, rules, "watch"),
        add: add.bind(null, rules, "watch")
      },
      add: add.bind(null, rules),
      rules
    };
  }
});

// ../../../node_modules/nodemon/lib/config/exec.js
var require_exec = __commonJS({
  "../../../node_modules/nodemon/lib/config/exec.js"(exports, module) {
    var path = require_path();
    var fs = require_fs();
    var existsSync = fs.existsSync;
    var utils = require_utils();
    module.exports = exec;
    module.exports.expandScript = expandScript;
    function execFromPackage() {
      try {
        var pkg = __require(path.join(process.cwd(), "package.json"));
        if (pkg.main !== void 0) {
          return { exec: null, script: pkg.main };
        }
        if (pkg.scripts && pkg.scripts.start) {
          return { exec: pkg.scripts.start };
        }
      } catch (e) {
      }
      return null;
    }
    function replace(map, str) {
      var re = new RegExp("{{(" + Object.keys(map).join("|") + ")}}", "g");
      return str.replace(re, function(all, m) {
        return map[m] || all || "";
      });
    }
    function expandScript(script, ext) {
      if (!ext) {
        ext = ".js";
      }
      if (script.indexOf(ext) !== -1) {
        return script;
      }
      if (existsSync(path.resolve(script))) {
        return script;
      }
      if (existsSync(path.resolve(script + ext))) {
        return script + ext;
      }
      return script;
    }
    function exec(nodemonOptions, execMap) {
      if (!execMap) {
        execMap = {};
      }
      var options = utils.clone(nodemonOptions || {});
      var script;
      if (!options.script && (options.args || []).length) {
        script = expandScript(
          options.args[0],
          options.ext && "." + (options.ext || "js").split(",")[0]
        );
        if (script !== options.args[0]) {
          options.script = script;
          options.args.shift();
        }
      }
      if (!options.exec && !options.script) {
        var found = execFromPackage();
        if (found !== null) {
          if (found.exec) {
            options.exec = found.exec;
          }
          if (!options.script) {
            options.script = found.script;
          }
          if (Array.isArray(options.args) && options.scriptPosition === null) {
            options.scriptPosition = options.args.length;
          }
        }
      }
      script = path.basename(options.script || "");
      var scriptExt = path.extname(script).slice(1);
      var extension = options.ext;
      if (extension === void 0) {
        var isJS = scriptExt === "js" || scriptExt === "mjs";
        extension = isJS || !scriptExt ? "js,mjs" : scriptExt;
        extension += ",json";
      }
      var execDefined = !!options.exec;
      if (!options.exec && execMap[scriptExt] !== void 0) {
        options.exec = execMap[scriptExt];
        execDefined = true;
      }
      options.execArgs = nodemonOptions.execArgs || [];
      if (Array.isArray(options.exec)) {
        options.execArgs = options.exec;
        options.exec = options.execArgs.shift();
      }
      if (options.exec === void 0) {
        options.exec = "node";
      } else {
        var substitution = replace.bind(null, {
          filename: options.script,
          pwd: process.cwd()
        });
        var newExec = substitution(options.exec);
        if (newExec !== options.exec && options.exec.indexOf("{{filename}}") !== -1) {
          options.script = null;
        }
        options.exec = newExec;
        var newExecArgs = options.execArgs.map(substitution);
        if (newExecArgs.join("") !== options.execArgs.join("")) {
          options.execArgs = newExecArgs;
          delete options.script;
        }
      }
      if (options.exec === "node" && options.nodeArgs && options.nodeArgs.length) {
        options.execArgs = options.execArgs.concat(options.nodeArgs);
      }
      if (!execDefined && options.exec === "node" && scriptExt.indexOf("coffee") !== -1) {
        options.exec = "coffee";
        var leadingArgs = (options.args || []).splice(0, options.scriptPosition);
        options.execArgs = options.execArgs.concat(leadingArgs);
        options.scriptPosition = 0;
        if (options.execArgs.length > 0) {
          options.execArgs = ["--nodejs", options.execArgs.join(" ")];
        }
      }
      if (options.exec === "coffee") {
        if (options.ext === void 0) {
          if (extension) {
            extension += ",";
          }
          extension += "coffee,litcoffee";
        }
        if (utils.isWindows) {
          options.exec += ".cmd";
        }
      }
      extension = (extension.match(/[^,*\s]+/g) || []).map((ext) => ext.replace(/^\./, "")).join(",");
      options.ext = extension;
      if (options.script) {
        options.script = expandScript(
          options.script,
          extension && "." + extension.split(",")[0]
        );
      }
      options.env = {};
      if ({}.toString.apply(nodemonOptions.env) === "[object Object]") {
        options.env = utils.clone(nodemonOptions.env);
      } else if (nodemonOptions.env !== void 0) {
        throw new Error("nodemon env values must be an object: { PORT: 8000 }");
      }
      return options;
    }
  }
});

// ../../../node_modules/ignore-by-default/index.js
var require_ignore_by_default = __commonJS({
  "../../../node_modules/ignore-by-default/index.js"(exports) {
    "use strict";
    exports.directories = function() {
      return [
        ".git",
        // Git repository files, see <https://git-scm.com/>
        ".nyc_output",
        // Temporary directory where nyc stores coverage data, see <https://github.com/bcoe/nyc>
        ".sass-cache",
        // Cache folder for node-sass, see <https://github.com/sass/node-sass>
        "bower_components",
        // Where Bower packages are installed, see <http://bower.io/>
        "coverage",
        // Standard output directory for code coverage reports, see <https://github.com/gotwarlost/istanbul>
        "node_modules"
        // Where Node modules are installed, see <https://nodejs.org/>
      ];
    };
  }
});

// ../../../node_modules/nodemon/lib/config/defaults.js
var require_defaults = __commonJS({
  "../../../node_modules/nodemon/lib/config/defaults.js"(exports, module) {
    var ignoreRoot = require_ignore_by_default().directories();
    module.exports = {
      restartable: "rs",
      colours: true,
      execMap: {
        py: "python",
        rb: "ruby",
        ts: "ts-node"
        // more can be added here such as ls: lsc - but please ensure it's cross
        // compatible with linux, mac and windows, or make the default.js
        // dynamically append the `.cmd` for node based utilities
      },
      ignoreRoot: ignoreRoot.map((_) => `**/${_}/**`),
      watch: ["*.*"],
      stdin: true,
      runOnChangeOnly: false,
      verbose: false,
      signal: "SIGUSR2",
      // 'stdout' refers to the default behaviour of a required nodemon's child,
      // but also includes stderr. If this is false, data is still dispatched via
      // nodemon.on('stdout/stderr')
      stdout: true,
      watchOptions: {}
    };
  }
});

// ../../../node_modules/nodemon/lib/config/load.js
var require_load = __commonJS({
  "../../../node_modules/nodemon/lib/config/load.js"(exports, module) {
    var debug = require_browser()("nodemon");
    var fs = require_fs();
    var path = require_path();
    var exists = fs.exists || path.exists;
    var utils = require_utils();
    var rules = require_rules();
    var parse = require_parse();
    var exec = require_exec();
    var defaults = require_defaults();
    module.exports = load;
    module.exports.mutateExecOptions = mutateExecOptions;
    var existsSync = fs.existsSync || path.existsSync;
    function findAppScript() {
      if (existsSync("./index.js")) {
        return "index.js";
      }
    }
    function load(settings, options, config, callback) {
      config.loaded = [];
      loadFile(options, config, utils.home, function(options2) {
        if (settings.configFile) {
          options2.configFile = path.resolve(settings.configFile);
        }
        loadFile(options2, config, process.cwd(), function(options3) {
          options3 = utils.merge(settings, options3);
          if (!Array.isArray(options3.ignore)) {
            options3.ignore = [options3.ignore];
          }
          if (!options3.ignoreRoot) {
            options3.ignoreRoot = defaults.ignoreRoot;
          }
          if (options3.ignoreRoot && options3.ignore) {
            if (!Array.isArray(options3.ignoreRoot)) {
              options3.ignoreRoot = [options3.ignoreRoot];
            }
            options3.ignore = options3.ignoreRoot.concat(options3.ignore);
          } else {
            options3.ignore = defaults.ignore.concat(options3.ignore);
          }
          options3 = utils.merge(options3, defaults);
          if (!options3.script && !options3.exec) {
            var found = findAppScript();
            if (found) {
              if (!options3.args) {
                options3.args = [];
              }
              const n = options3.scriptPosition === null ? options3.args.length : options3.scriptPosition;
              options3.execArgs = (options3.execArgs || []).concat(options3.args.splice(0, n));
              options3.scriptPosition = null;
              options3.script = found;
            }
          }
          mutateExecOptions(options3);
          if (options3.quiet) {
            utils.quiet();
          }
          if (options3.verbose) {
            utils.debug = true;
          }
          var ready = function(options4) {
            normaliseRules(options4, callback);
          };
          if (config.loaded.length === 0) {
            var legacy = loadLegacyIgnore.bind(null, options3, config, ready);
            return legacy(".nodemonignore", function() {
              legacy("nodemon-ignore", function(options4) {
                ready(options4);
              });
            });
          }
          ready(options3);
        });
      });
    }
    function loadLegacyIgnore(options, config, success, filename, fail) {
      var ignoreFile = path.join(process.cwd(), filename);
      exists(ignoreFile, function(exists2) {
        if (exists2) {
          config.loaded.push(ignoreFile);
          return parse(ignoreFile, function(error, rules2) {
            options.ignore = rules2.raw;
            success(options);
          });
        }
        if (fail) {
          fail(options);
        } else {
          success(options);
        }
      });
    }
    function normaliseRules(options, ready) {
      rules.watch.add(options.watch);
      rules.ignore.add(options.ignore);
      options.watch = options.watch === false ? false : rules.rules.watch;
      options.ignore = rules.rules.ignore;
      ready(options);
    }
    function loadFile(options, config, dir, ready) {
      if (!ready) {
        ready = function() {
        };
      }
      var callback = function(settings) {
        ready(utils.merge(settings, options));
      };
      if (!dir) {
        return callback({});
      }
      var filename = options.configFile || path.join(dir, "nodemon.json");
      if (config.loaded.indexOf(filename) !== -1) {
        return callback({});
      }
      fs.readFile(filename, "utf8", function(err, data) {
        if (err) {
          if (err.code === "ENOENT") {
            if (!options.configFile && dir !== utils.home) {
              return loadPackageJSON(config, callback);
            }
          }
          return callback({});
        }
        var settings = {};
        try {
          settings = JSON.parse(data.toString("utf8").replace(/^\uFEFF/, ""));
          if (!filename.endsWith("package.json") || settings.nodemonConfig) {
            config.loaded.push(filename);
          }
        } catch (e) {
          utils.log.fail("Failed to parse config " + filename);
          console.error(e);
          process.exit(1);
        }
        callback(settings);
      });
    }
    function loadPackageJSON(config, ready) {
      if (!ready) {
        ready = () => {
        };
      }
      const dir = process.cwd();
      const filename = path.join(dir, "package.json");
      const packageLoadOptions = { configFile: filename };
      return loadFile(packageLoadOptions, config, dir, (settings) => {
        ready(settings.nodemonConfig || {});
      });
    }
    function mutateExecOptions(options) {
      options.execOptions = exec({
        script: options.script,
        exec: options.exec,
        args: options.args,
        scriptPosition: options.scriptPosition,
        nodeArgs: options.nodeArgs,
        execArgs: options.execArgs,
        ext: options.ext,
        env: options.env
      }, options.execMap);
      delete options.scriptPosition;
      delete options.script;
      delete options.args;
      delete options.ext;
      return options;
    }
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// ../../../node_modules/nodemon/lib/version.js
var require_version = __commonJS({
  "../../../node_modules/nodemon/lib/version.js"(exports, module) {
    module.exports = version;
    module.exports.pin = pin;
    var fs = require_fs();
    var path = require_path();
    var exec = require_child_process().exec;
    var root = null;
    function pin() {
      return version().then(function(v) {
        version.pinned = v;
      });
    }
    function version(callback) {
      var promise = findPackage(path.dirname(module.parent.filename)).then(function(dir) {
        var v = __require(path.resolve(dir, "package.json")).version;
        if (v && v !== "0.0.0-development") {
          return v;
        }
        root = dir;
        var promises = [
          branch().catch(function() {
            return "master";
          }),
          commit().catch(function() {
            return "<none>";
          }),
          dirty().catch(function() {
            return 0;
          })
        ];
        return Promise.all(promises).then(function(res) {
          var branch2 = res[0];
          var commit2 = res[1];
          var dirtyCount = parseInt(res[2], 10);
          var curr = branch2 + ": " + commit2;
          if (dirtyCount !== 0) {
            curr += " (" + dirtyCount + " dirty files)";
          }
          return curr;
        });
      }).catch(function(error) {
        console.log(error.stack);
        throw error;
      });
      if (callback) {
        promise.then(function(res) {
          callback(null, res);
        }, callback);
      }
      return promise;
    }
    function findPackage(dir) {
      if (dir === "/") {
        return Promise.reject(new Error("package not found"));
      }
      return new Promise(function(resolve) {
        fs.stat(path.resolve(dir, "package.json"), function(error, exists) {
          if (error || !exists) {
            return resolve(findPackage(path.resolve(dir, "..")));
          }
          resolve(dir);
        });
      });
    }
    function command(cmd) {
      return new Promise(function(resolve, reject) {
        exec(cmd, { cwd: root }, function(err, stdout, stderr) {
          var error = stderr.trim();
          if (error) {
            return reject(new Error(error));
          }
          resolve(stdout.split("\n").join(""));
        });
      });
    }
    function commit() {
      return command("git rev-parse HEAD");
    }
    function branch() {
      return command("git rev-parse --abbrev-ref HEAD");
    }
    function dirty() {
      return command('expr $(git status --porcelain 2>/dev/null| egrep "^(M| M)" | wc -l)');
    }
  }
});

// ../../../node_modules/nodemon/lib/config/command.js
var require_command = __commonJS({
  "../../../node_modules/nodemon/lib/config/command.js"(exports, module) {
    module.exports = command;
    function command(settings) {
      var options = settings.execOptions;
      var executable = options.exec;
      var args = [];
      if (options.execArgs) {
        [].push.apply(args, options.execArgs);
      }
      if (options.args) {
        [].push.apply(args, options.args);
      }
      if (options.script) {
        args.splice((options.scriptPosition || 0) + options.execArgs.length, 0, options.script);
      }
      return {
        executable,
        args
      };
    }
  }
});

// ../../../node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../../../node_modules/concat-map/index.js"(exports, module) {
    module.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../../../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../../../node_modules/balanced-match/index.js"(exports, module) {
    "use strict";
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../../../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../../../node_modules/brace-expansion/index.js"(exports, module) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../../../node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../../../node_modules/minimatch/minimatch.js"(exports, module) {
    module.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require_path();
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file, pattern }
      );
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../../../node_modules/nodemon/lib/monitor/match.js
var require_match = __commonJS({
  "../../../node_modules/nodemon/lib/monitor/match.js"(exports, module) {
    var minimatch = require_minimatch();
    var path = require_path();
    var fs = require_fs();
    var debug = require_browser()("nodemon:match");
    var utils = require_utils();
    module.exports = match;
    module.exports.rulesToMonitor = rulesToMonitor;
    function rulesToMonitor(watch, ignore, config) {
      var monitor = [];
      if (!Array.isArray(ignore)) {
        if (ignore) {
          ignore = [ignore];
        } else {
          ignore = [];
        }
      }
      if (!Array.isArray(watch)) {
        if (watch) {
          watch = [watch];
        } else {
          watch = [];
        }
      }
      if (watch && watch.length) {
        monitor = utils.clone(watch);
      }
      if (ignore) {
        [].push.apply(monitor, (ignore || []).map(function(rule) {
          return "!" + rule;
        }));
      }
      var cwd = process.cwd();
      monitor = monitor.map(function(rule) {
        var not = rule.slice(0, 1) === "!";
        if (not) {
          rule = rule.slice(1);
        }
        if (rule === "." || rule === ".*") {
          rule = "*.*";
        }
        var dir = path.resolve(cwd, rule);
        try {
          var stat = fs.statSync(dir);
          if (stat.isDirectory()) {
            rule = dir;
            if (rule.slice(-1) !== "/") {
              rule += "/";
            }
            rule += "**/*";
            if (!not) {
              config.dirs.push(dir);
            }
          } else {
            throw new Error();
          }
        } catch (e) {
          var base = tryBaseDir(dir);
          if (!not && base) {
            if (config.dirs.indexOf(base) === -1) {
              config.dirs.push(base);
            }
          }
        }
        if (rule.slice(-1) === "/") {
          rule += "*";
        }
        if (rule.slice(-4) !== "**/*" && rule.slice(-1) === "*" && rule.indexOf("*.") === -1) {
          if (rule.slice(-2) !== "**") {
            rule += "*/*";
          }
        }
        return (not ? "!" : "") + rule;
      });
      return monitor;
    }
    function tryBaseDir(dir) {
      var stat;
      if (/[?*\{\[]+/.test(dir)) {
        try {
          var base = path.dirname(dir.replace(/([?*\{\[]+.*$)/, "foo"));
          stat = fs.statSync(base);
          if (stat.isDirectory()) {
            return base;
          }
        } catch (error) {
        }
      } else {
        try {
          stat = fs.statSync(dir);
          if (stat.isFile() || stat.isDirectory()) {
            return dir;
          }
        } catch (e) {
        }
      }
      return false;
    }
    function match(files, monitor, ext) {
      const cwd = process.cwd();
      var rules = monitor.sort(function(a, b) {
        var r = b.split(path.sep).length - a.split(path.sep).length;
        var aIsIgnore = a.slice(0, 1) === "!";
        var bIsIgnore = b.slice(0, 1) === "!";
        if (aIsIgnore || bIsIgnore) {
          if (aIsIgnore) {
            return -1;
          }
          return 1;
        }
        if (r === 0) {
          return b.length - a.length;
        }
        return r;
      }).map(function(s) {
        var prefix = s.slice(0, 1);
        if (prefix === "!") {
          if (s.indexOf("!" + cwd) === 0) {
            return s;
          }
          if (s.indexOf("!.") === 0) {
            return "!" + path.resolve(cwd, s.substring(1));
          }
          return "!**" + (prefix !== path.sep ? path.sep : "") + s.slice(1);
        }
        if (s.indexOf(".") === 0) {
          return path.resolve(cwd, s);
        }
        if (s.indexOf(cwd) === 0) {
          return s;
        }
        return "**" + (prefix !== path.sep ? path.sep : "") + s;
      });
      debug("rules", rules);
      var good = [];
      var whitelist = [];
      var ignored = 0;
      var watched = 0;
      var usedRules = [];
      var minimatchOpts = {
        dot: true
      };
      if (utils.isWindows) {
        minimatchOpts.nocase = true;
      }
      files.forEach(function(file) {
        file = path.resolve(cwd, file);
        var matched = false;
        for (var i = 0; i < rules.length; i++) {
          if (rules[i].slice(0, 1) === "!") {
            if (!minimatch(file, rules[i], minimatchOpts)) {
              debug("ignored", file, "rule:", rules[i]);
              ignored++;
              matched = true;
              break;
            }
          } else {
            debug("matched", file, "rule:", rules[i]);
            if (minimatch(file, rules[i], minimatchOpts)) {
              watched++;
              if (usedRules.indexOf(rules[i]) === -1) {
                usedRules.push(rules[i]);
                utils.log.detail("matched rule: " + rules[i]);
              }
              if (rules[i] !== "**" + path.sep + "*.*" && rules[i].slice(-3) === "*.*") {
                whitelist.push(file);
              } else if (path.basename(file) === path.basename(rules[i])) {
                whitelist.push(file);
              } else {
                good.push(file);
              }
              matched = true;
              break;
            } else {
            }
          }
        }
        if (!matched) {
          ignored++;
        }
      });
      debug("good", good);
      if (ext) {
        if (ext.indexOf(",") === -1) {
          ext = "**/*." + ext;
        } else {
          ext = "**/*.{" + ext + "}";
        }
        good = good.filter(function(file) {
          return minimatch(path.basename(file), ext, minimatchOpts);
        });
      }
      var result = good.concat(whitelist);
      if (utils.isWindows) {
        result = result.map(function(file) {
          return file.slice(0, 1).toLowerCase() + file.slice(1);
        });
      }
      return {
        result,
        ignored,
        watched,
        total: files.length
      };
    }
  }
});

// ../../../node_modules/nodemon/lib/config/index.js
var require_config = __commonJS({
  "../../../node_modules/nodemon/lib/config/index.js"(exports, module) {
    var debug = require_browser()("nodemon");
    var load = require_load();
    var rules = require_rules();
    var utils = require_utils();
    var pinVersion = require_version().pin;
    var command = require_command();
    var rulesToMonitor = require_match().rulesToMonitor;
    var bus = utils.bus;
    function reset() {
      rules.reset();
      config.dirs = [];
      config.options = { ignore: [], watch: [], monitor: [] };
      config.lastStarted = 0;
      config.loaded = [];
    }
    var config = {
      run: false,
      system: {
        cwd: process.cwd()
      },
      required: false,
      dirs: [],
      timeout: 1e3,
      options: {}
    };
    config.load = function(settings, ready) {
      reset();
      var config2 = this;
      load(settings, config2.options, config2, function(options) {
        config2.options = options;
        if (options.watch.length === 0) {
          options.watch.push("*.*");
        }
        if (options["watch_interval"]) {
          options.watchInterval = options["watch_interval"];
        }
        config2.watchInterval = options.watchInterval || null;
        if (options.signal) {
          config2.signal = options.signal;
        }
        var cmd = command(config2.options);
        config2.command = {
          raw: cmd,
          string: utils.stringify(cmd.executable, cmd.args)
        };
        options.monitor = rulesToMonitor(options.watch, options.ignore, config2);
        var cwd = process.cwd();
        debug("config: dirs", config2.dirs);
        if (config2.dirs.length === 0) {
          config2.dirs.unshift(cwd);
        }
        bus.emit("config:update", config2);
        pinVersion().then(function() {
          ready(config2);
        }).catch((e) => {
          console.error(e.stack);
          setTimeout(() => {
            throw e;
          }, 0);
        });
      });
    };
    config.reset = reset;
    module.exports = config;
  }
});
export default require_config();
//# sourceMappingURL=nodemon_lib_config.js.map
